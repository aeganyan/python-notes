# -*- coding: utf-8 -*-

#-------------------------------------------------------------------------------
# Copyright (c) 2015 Artur Eganyan
#
# This work is provided "AS IS", WITHOUT ANY WARRANTY, express or implied.
#-------------------------------------------------------------------------------

# Кратко:
# - любые данные - это объекты
# - любой объект имеет идентификатор, тип и значение
# - идентификатор уникален для объекта, возвращается функцией id() (обычно это его адрес в памяти)
# - тип возвращается функцией type()
# - объект может быть изменяемым (mutable object) и неизменяемым (immutable object)
# - под изменяемостью имеется в виду изменяемость значения объекта (например, содержимое списка)


# Любые данные - это объекты. Каждый объект имеет идентификатор, тип и значение.
# Все переменные хранят ссылки на объекты.
#
# Идентификатор возвращается функцией id(), он уникален для объекта и обычно 
# совпадает с его адресом в памяти. Оператор is проверяет равенство
# идентификаторов двух объектов: <объект1> is <объект2>.
#
# Тип возвращается функцией type(). После создания объекта его тип нельзя
# изменить (почти никогда).
#
# Значение объекта может быть изменяемым (mutable object) или неизменяемым
# (immutable object). При этом неизменяемый объект может состоять из
# изменяемых: например, неизменяемый кортеж (tuple) из изменяемых списков
# (list) вроде ([1, 2], [3, 4, 5], [6, 7]) - можно изменить содержимое
# списков, но нельзя добавить или удалить список в кортеже.
#
# Примеры неизменяемых объектов: любое число, строка, кортеж. Неизменяемые
# объекты обычно хешируются. Т.е., если нужно какое-то значение, и объект
# с таким значением уже создан, используется ссылка на этот объект: a = 1,
# b = 1 - тут a и b могут ссылаться на один и тот же объект-число.


# Численные типы: int, long, float, complex
x = 1           # int, он же "plain integer": [-2147483648, 2147483647]
y = 2**100      # long, он же "long integer": любое число > int. Ограничен
                # объемом доступной памяти, хранится в двоичной системе,
                # отрицательные числа представляются в дополнительной форме.
z = x + y       # Преобразование между int/long делается автоматически 
print x, y, z   # 1 1267650600228229401496703205376 1267650600228229401496703205377
x = 1.5e2       # float - вещественные числа (обычно - двойной точности)
print x         # 150.0
x = 10 + 5j     # complex - пара вещественных чисел (float, float)
print x, x.real, x.imag # (10+5j) 10.0 5.0

# Логический тип bool. Является подклассом int. Преобразование в
# число дает 1 для True и 0 для False.
b = True


# Последовательности: str, unicode, tuple, list, byte array
# Это конечный упорядоченный набор элементов, пронумерованных от 0 до len()-1.
# len() возвращает количество элементов, a[i:j] возвращает интервал [i; j),
# a[i:j:s] для некоторых последовательностей возвращает элементы из [i; j)
# с шагом s. Можно перебрать элементы, например через for ... in.

# Immutable: str, unicode, tuple
# str
s = "abc"       # Последовательность байт. Значение каждого байта может пониматься программой
                # как ASCII-код или как-то иначе. При выводе на экран через print байты
                # отображаются в соответствии с кодировкой терминала.
c = 'a'         # Для символа нет отдельного типа, символ - это строка из 1 элемента
c = "a"         # -//-
print ord(c)    # 97 (ASCII-код символа "a")
print chr(97)   # a

# unicode
s = u"abc"      # Последовательность юникодов ("кодовых точек"), размер юникода - 2 или 4 байта.
                # При выводе на экран или записи в файл юникоды кодируются в соответствии
                # с кодировкой терминала/файла (открыть файл в нужной кодировке можно
                # функцией open из модуля codecs).

# tuple
t = (1, 2, 3)  # Кортеж
t = 1, 4, 5    # Скобки не обязательны (они нужны для группировки в выражениях)
t = 7,         # Кортеж из 1 элемента, нужна запятая в конце
t = (7,)       # -//-
t = (7)        # Просто число 7
t = ()         # Пустой кортеж

# Mutable: list, byte array
# list
a = [0, 2, 3]       # Список
a[0] = 1            # Можно изменять элементы
print a, len(a)     # [1, 2, 3] 3
print a[0:0]        # [] - пустой список
print a[0:1]        # [1]
print a[0:3:2]      # [1, 3]
a[0:0] = [5]        # [5, 1, 2, 3] - вставит 5 в начало списка. a[0:0] означает "ссылка на список,
                    # начинающийся с нулевого элемента, не включая этот элемент" (т.е. ссылка на
                    # начало нулевого элемента)
a[0:2] = [0, 0]     # [0, 0, 2, 3]
a[0:2] = [0, 0, 0]  # [0, 0, 0, 2, 3]
a = [1, 2, 3]
a[3:3] = [4, 5]     # [1, 2, 3, 4, 5]
a[0:2] = [1]        # [1, 3, 4, 5]
a[0:4:2] = [0, 0]   # [0, 3, 0, 5]
#a[0:4:2] = [0]     # Ошибка, потому что a[0:4:2] не является ссылкой на последовательно идущие элементы

# byte array
b = bytearray([97, 97, 97]) # Массив байт, поддерживает большинство операций последовательностей и строк
print b              # aaa
b = bytearray("aaa") # -//-
b[1:3] = [98, 99]    # abc
del b[1:2]           # ac
b[1:1] = ["b"]       # abc
print b.upper()      # ABC
print b.center(5)    # " abc "


# Множества: set, frozenset
# Это неупорядоченный конечный набор неизменяемых элементов (нумерации нет).
# len() возвращает количество элементов. Можно перебрать элементы,
# например через for ... in.

# set (mutable)
s = set([1, 2, 3])    # Множество, для которого можно добавлять/удалять элементы
print s               # set([1, 2, 3])
s.remove(1)           # (2, 3), remove() может сгенерировать исключение KeyError, если элемента нет
s.discard(1)          # -//-, но discard() не генерирует исключение
s.add(1)              # (1, 2, 3)
print s.union([1, 4]) # set([1, 2, 3, 4])
for e in s:
    print e           # 1 2 3

# fronzen set (immutable)
s = frozenset([1, 2, 3])     # Множество, которое нельзя изменять
print s                      # frozenset([1, 2, 3])
print s.intersection([1, 3]) # frozenset([1, 3])


# Словарь: dict
# Это конечный набор элементов, проиндексированных произвольными значениями.
# len() возвращает количество элементов, a[k] возвращает элемент с индексом k.
# Замечание: В документации словарь еще называют "mapping".
a = dict(b=1, c=2, d=3)      # Карта вида b->1, c->2, d->3
a = dict([('b', 1), ('c', 2), ('d', 3)]) # -//-
a = {'b': 1, 'c': 2, 'd': 3} # -//-
print a                      # {'c': 2, 'b': 1, 'd': 3} - порядок не отсортирован
del a['b']                   # {'c': 2, 'd': 3}
a['b'] = 1                   # {'c': 2, 'b': 2, 'd': 3}
for k in a:
    print k, a[k]            # c 2, b 1, d 3


# list/set/dict comprehension - это способ создания списка/множества/словаря
# в одну строку. Для списка это:
#
# [<элемент> for ... <for ...|if ...> <for ...|if ...> ...]
#
# Эта запись эквивалента коду:
#
# a = []
# for ...
#     for ... | if ...
#         for ... | if ...  
#             a.append(<элемент>)
#
# Для множества и словаря запись такая же, только скобки меняются на
# фигурные {}, и для словаря <элемент> имеет вид <ключ: значение>.

a = [i * 2 for i in range(5)] # [0, 2, 4, 6, 8]
s = {i * 2 for i in a}        # set([0, 4, 8, 12, 16])
d = {i: i * 2 for i in s}     # {0:0, 4:8, 8:16, 12:24, 16:32}


# Пример того, что неизменяемый объект может хэшироваться (см. выше про объекты)
a = 1
b = 1
print id(a)  # Идентификаторы могут быть одинаковыми, т.е. a и b могут хранить
print id(b)  # ссылку на один и тот же неизменяемый объект-число.


# В документации есть понятия "tuple packing" и "sequence unpacking"

# tuple packing - упаковка объектов в кортеж (т.е. просто создание кортежа)
t = 1, "text", [1, 2, 3]  # Кортеж из 3 элементов

# sequence unpacking - присваивание элементов последовательности переменным
a, b, c = t              # a == 1, b == "text", c == [1, 2, 3]
a, b, c = 1, 2, 3        # Здесь сначала будет создан кортеж (1, 2, 3), а потом "распакован" в a, b, c 
a, b, c = [1, 2, 3]      # То же самое, но используется список, а не кортеж
a, b, c = set([2, 3, 1]) # Интересно, что это тоже работает, хотя set - неупорядоченная последовательность,
                         # и при запуске скрипта в a попадала 1, в b - 2, в c - 3


# Сравнение объектов
#
# Можно использовать цепочки сравнений без явных "and":
#
# a < b == c - это то же, что a < b and b == c
#
# Операторы and/or - "ленивые", вычисления останавливаются на первом
# False/True. Результат таких операторов - последнее вычисленное значение
# (не обязательно bool). Результат приводится к bool, если это нужно -
# например, если операторы находятся в условии if/while.
#
# Последовательности сравниваются лексикографически, т.е. поэлементно,
# начиная с первых элементов. Если все элементы совпадают, но первая
# последовательность короче, она считается меньшей. Если элемент сам
# является последовательностью, для него выполняется рекурсивное сравнение.
#
# Важно: Если сравниваются последовательности разных типов, результат в
# python 2.x равен сравнению _названий_ этих типов, а не содержимого
# последовательностей. Например, list всегда меньше string, а string
# всегда меньше tuple.

x = 0 or 1 or 2     # x == 1
x = 1 > 2 or 5 > 1  # x == True (5 > 1)

def f(x):
    print "f(", x, ")"
    return x

print f(0) < f(1) == f(2)  # Вызовет f(0), f(1), f(2), вернет False
print f(1) < f(0) == f(2)  # Вызовет f(1), f(0), вернет False 


# Замечание: В python 3.x "тип" и "класс" являются синонимами, в 2.x это верно 
# только для new-style классов (см. заметку про классы).
#
# Замечание: Иногда под значением объекта понимаются значения тех объектов,
# на которые он ссылается (например, для кортежа ([1, 2], [3, 4, 5]) это 
# находящиеся в нем списки). Тогда "immutable" означает неизменность ссылок 
# на эти объекты, а не самих объектов.
#
# Замечание: Термины "хешируемый" (hashable) и "неизменяемый" (immutable)
# иногда используют как синонимы. Однако неизменяемый объект вроде кортежа
# может быть не хешируемым, если он содержит изменяемые элементы:
# hash( ([1, 2], [3, 4]) ) сгенерирует "TypeError: unhashable type: 'list'".
#
# Замечание: В документации строка (str) называется последовательностью
# символов, и далее уточняется, что "символы представляют (по меньшей мере)
# 8-битные байты". И там же говорится, что строки "также используются
# для представления массива байт". Не знаю, есть ли в какой-либо реализации
# python строки, где каждый элемент занимает больше 8 бит. Также, понятие
# "символ строки" может вводить в заблуждение, т.к. не во всех кодировках
# символ представляется одним байтом - в той же utf-8 строка "текст" займет
# 10 байт, а не 5. Подробнее о кодировках см. заметку "encoding". Для
# юникод-строк (тип unicode) понятие "символ" подходит лучше, т.к. там
# каждый символ представлен юникодом, занимающим 2 или 4 байта (видимо,
# в зависимости от реализации python).
#
# Замечание: В python 3.x все строки хранятся в юникоде, независимо от
# наличия префикса "u" перед строкой.
