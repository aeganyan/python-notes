# -*- coding: utf-8 -*-

#-------------------------------------------------------------------------------
# Copyright (c) 2015 Artur Eganyan
#
# This work is provided "AS IS", WITHOUT ANY WARRANTY, express or implied.
#-------------------------------------------------------------------------------

# Модуль - файл, содержащий код, с расширением:
# - *.py - текстовый файл
# - *.pyc - скомпилированный код (байт-код)
# - *.pyo - скомпилированный и оптимизированный код
#
# Файлы с скомпилированным кодом (*.pyc, *.pyo) создаются и обновляются
# автоматически, после каждой компиляции *.py. Затем, когда интерпретатор
# ищет модуль.py и видит рядом модуль.pyc или модуль.pyo, он выберет
# скомпилированный код (если он не устарел). 
#
# Замечание: Под оптимизацией в python 2.x подразумевается удаление инструкций
# assert и, при "сильной" оптимизации, удаление документации к функциям и
# классам. Поэтому *.pyo быстрее *.pyc только по скорости загрузки (*.pyo
# меньше по размеру), но не отличается по скорости выполнения. Оптимизация
# делается при запуске интерпретатора с флагом -O или -OO ("сильная", для
# которой в python 2.x не гарантируется стабильность).
#
# Модуль подключается любой из следующих инструкций:
# 1. import <модуль>
# 2. from <модуль> import <объект1>, <объект2>, ...
# 3. from <модуль> import *
#
# Инструкции не обязательно размещать в начале модуля. Однако вариант 3
# разрешается использовать только в коде модуля, а не в коде функции или 
# класса (правда, при использовании внутри функции выводится только warning 
# и подключение, похоже, срабатывает).
#
# В случае 1 создается ссылка на <модуль>, через которую можно обратиться
# к содержимому модуля: <модуль>.<объект>. В 2 и 3 создаются ссылки на
# импортируемые объекты ("*" означает "все объекты модуля"), но не ссылка
# на модуль.
#
# Пути поиска модуля:
# 1. Среди встроенных модулей
# 2. В директориях из списка sys.path:
#   - в директории скрипта (текущая директория)
#   - в директориях из переменной окружения PYTHONPATH
#   - в стандартных директориях, зависящих от расположения python
# Список sys.path можно менять.
#
# Модуль при первом подключении загружается и выполняется - т.е. выполняется
# весь код, содержащийся в нем (кодом являются даже объявления функций и
# классов). При этом не важно, как модуль был подключен - через import или 
# from ... import.
#
# Глобальная переменная __name__, существующая в каждом модуле, хранит его
# имя. __name__ становится равной "__main__" когда модуль не подключается,
# а запускается как скрипт (через интерпретатор). Поэтому можно выполнять
# определенный код для таких случаев:
# if __name__ == "__main__":
#     <код (например, тест модуля)>

# Ниже module1 будет загружен и выполнен только один раз - при первом
# подключении. Но загрузка и выполнение делаются при любом первом подключении, 
# даже если это from module1 import f.

import module1          # Будет загружен и выполнен module1.py, после чего
                        # будет создана ссылка module1
print module1.x         # 1
module1.f()             # module1.f()

from module1 import f   # Будет создана ссылка f на module1.f
f()                     # module1.f()

from module1 import *   # Будут созданы ссылки на все объекты module1
print x                 # 1

print module1.__name__  # module1
print __name__          # __main__

import sys
print sys.path          # Список директорий, в которых ищутся подключаемые модули

sys.path = []           # Теперь import module1 привел бы к ошибке, поскольку
                        # модуль не был бы найден
