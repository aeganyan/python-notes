# -*- coding: utf-8 -*-

#-------------------------------------------------------------------------------
# Copyright (c) 2015 Artur Eganyan
#
# This work is provided "AS IS", WITHOUT ANY WARRANTY, express or implied.
#-------------------------------------------------------------------------------

# Когда создается экземпляр класса через "класс(параметры)", вызывается
# конструктор класс.__new__(класс, параметры), который должен создать и 
# вернуть экземпляр. Далее вызывается класс.__init__(экземпляр, параметры),
# чтобы проинициализировать этот экземпляр.
#
# Обычно __new__ для создания экземпляра вызывает __new__ родительского 
# класса, например object.__new__(класс, параметры). Чтобы не указывать 
# родителя явно, можно использовать super():
#
# super(текущий класс, класс).__new__(класс, параметры)
#
# Тут текущий класс должен либо совпадать с классом создаваемого экземпляра,
# либо быть его родителем (как A является родителем B в примере ниже).
# 
# Замечание: В отличие от остальных методов класса, __new__ - это
# статический метод. 
#
# Замечание: Если __new__() вернет экземпляр, не относящийся к создаваемому
# классу или его потомкам, то __init__() не будет вызван.


# Здесь A.__new__() вызывает object.__new__(), передавая ему свои
# параметры, а потом добавляет в созданный экземпляр атрибут, просто так
# (конечно, то же самое лучше делать через __init__()).
class A(object):
    def __new__(cls, *args):
        instance = super(A, cls).__new__(cls, *args)
        instance.test = u"Конструктор __new__ добавил этот атрибут"
        return instance

    def __init__(self, x, y):
        print "A.__init__"
        self.x = x
        self.y = y
    
class B(A):
    def __init__(self):
        print "B.__init__"

a = A(1, 2) # Вызовет A.__new__(A, 1, 2), получит созданный экземпляр, проверит
            # isinstance(экземпляр, A), и вызовет A.__init__(экземпляр, 1, 2)

b = B()     # Вызовет A.__new__(B), получит созданный экземпляр, проверит
            # isinstance(экземпляр, B), и вызовет B.__init__(экземпляр)
            
print a.x, a.y, a.test


# Если созданный экземпляр не относится к нужному классу, то __init__ 
# не будет вызван.
class C(object):
    pass

class D(object):
    def __new__(cls):
        return C() # Возвращается экземпляр другого класса

    def __init__(self):
        print u"Этот метод не будет вызван"

d = D()


# Автоматический вызов __init__ делает именно функция создания экземпляра 
# "класс(параметры)", а не __new__.
a = A.__new__(A) # __init__ не будет вызван
#print a.x # AttributeError: 'A' object has no attribute 'x'


# Похоже, object.__new__(класс, параметры) проверяет наличие __init__ в классе 
# и его родителях. Если такой конструктор есть, параметры просто игнорируются
# (они не нужны в object.__new__). Но если __init__ нет, выводится ошибка,
# т.к. параметры некуда будет передавать в дальнейшем. Интересно, что это 
# делает вызов __new__(), а не вызов "класс(параметры)".
class C(object):
    def __init__(self, x, y):
        pass

class D(object):
    pass

c = object.__new__(C, 1)  # Несмотря на то, что C.__init__() нужно два параметра
                          # (x и y), ошибки не будет - object.__new__ достаточно
                          # знать, что метод __init__ определен.

#d = object.__new__(D, 1) # TypeError: object() takes no parameters
                          # object.__new__ видит, что __init__ не определен,
                          # поэтому параметры точно нельзя передавать.
