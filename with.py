# -*- coding: utf-8 -*-

#-------------------------------------------------------------------------------
# Copyright (c) 2015 Artur Eganyan
#
# This work is provided "AS IS", WITHOUT ANY WARRANTY, express or implied.
#-------------------------------------------------------------------------------

# Кратко:
# - with позволяет обработать начало и конец блока кода
# - with использует менеджер контекста, у которого есть методы __enter__() и __exit__()
# - __enter__() вызывается перед выполнением блока кода
# - __exit__() вызывается после выполнения блока кода
# - менеджер контекста можно создать в виде генератора, используя декоратор @contextmanager


# Инструкция with позволяет обработать начало и конец выполнения блока кода:
#
# with <менеджер контекста> [as <переменная>]:
#     <код>
#
# <менеджер контекста> - это объект с методами __enter__() и __exit__(). 
# Метод __enter__() вызывается перед выполнением <кода>, и его результат  
# присваивается в <переменную>. Метод __exit__() вызывается после выполнения 
# кода, независимо от того, как код завершился - нормально, исключением, 
# возвратом (return) или прерыванием цикла (break/continue, если with 
# внутри цикла).
#
# Хорошая статья про with: "The Python "with" Statement by Example",
# http://preshing.com/20110920/the-python-with-statement-by-example/

class MyContextManager:
    def __enter__(self):
        print u"Начало выполнения кода"

    def __exit__(self, *args):
        print u"Конец выполнения кода"

# Замечание: в with передается экземпляр менеджера, а не класс 
with MyContextManager(): # Вызовет менеджер.__enter__()
    print 1
    print 2
    print 3
                         # Вызовет менеджер.__exit__()

def f():
    with MyContextManager() as c: # Вызовет менеджер.__enter__()
        print 1
        print 2
        return                    # Здесь with будет прерван
        print 3                   
                                  # Вызовет менеджер.__exit__()
    print u"Эта строка не выполнится"
    
f()

# Инструкция with очень похожа на try/except/finally, просто она удобнее для 
# определенных задач. Если в блоке кода произойдет исключение, оно будет 
# передано в __exit__() как три параметра: тип исключения, значение и стек 
# вызовов. И если __exit__() вернет True, то будет считаться, что исключение 
# обработано, а иначе оно будет сгенерировано повторно. 

class MyContextManager():
    def __enter__(self):
        print u"Начало выполнения кода"

    def __exit__(self, exc_type, exc_value, exc_traceback):
        print u"Произошло исключение", exc_type, exc_value
        print u"Конец выполнения кода"
        return True

with MyContextManager():
    print 1
    raise Exception("test")
    print 2
    # Произошло исключение <type 'exceptions.Exception'> test

# Менеджер контекста можно создать и в виде генератора, поместив перед ним 
# декоратор @contextmanager. У такого генератора yield должен выполняться 
# ровно один раз, возвращая значение, которое будет связано с переменной в 
# with (или возвращая None).

from contextlib import contextmanager

@contextmanager
def myContextManager():
    print u"Начало выполнения кода"
    yield                # Здесь можно вернуть значение для переменной with
    print u"Конец выполнения кода"

with myContextManager(): # Выполнит функцию до yield
    print 1
    print 2
    print 3
                         # Выполнит функцию после yield

# Если в блоке кода with произойдет исключение, оно будет сгенерировано
# на инструкции yield. Там генератор может его перехватить. Если из
# генератора не выйдет никакого исключения, то оно будет считаться
# обработанным (аналогично возврату True из __exit__()).

@contextmanager
def myContextManager():
    print u"Начало выполнения кода"
    try:
        yield
    except Exception as e:
        print u"Произошло исключение", e
    finally:
        print u"Конец выполнения кода"

with myContextManager(): # Выполнит функцию до yield
    print 1
    raise Exception("test")
    print 2
                         # Выполнит функцию после yield, сгенерировав исключение
                         # (по сути, выполнит генератор.throw(исключение))

# Замечание: Судя по всему, вариант с генератором устроен примерно следующим 
# образом. Декоратор @contextmanager преобразует генератор в класс "менеджер 
# контекста". Этот менеджер в функции __enter__() вызывает генератор и 
# возвращает результат yield, который with поместит в переменную (если она 
# указана). В функции __exit__() менеджер вызовет генератор.next(), если не 
# было исключения, или генератор.throw(), если было. Если при этом из 
# генератора выйдет исключение, то __exit__() вернет False, а иначе - True.
