# -*- coding: utf-8 -*-

#-------------------------------------------------------------------------------
# Copyright (c) 2015 Artur Eganyan
#
# This work is provided "AS IS", WITHOUT ANY WARRANTY, express or implied.
#-------------------------------------------------------------------------------

# В python 2.x есть два типа строк - обычные строки ("...") и юникод-строки 
# (u"..."). Обычные строки - это последовательность байт. Юникод-строки - 
# это последовательность "кодовых точек", размер которых 2 или 4 байта.
# "Кодовая точка" (далее для краткости - "юникод") - это по сути просто
# идентификатор символа.
#
# Чтобы понять/отобразить обычную строку, надо знать кодировку, в которой
# она записана. Т.е. надо знать, что означают байты этой строки (каким
# символам они соответствуют). Чтобы понять/отобразить юникод-строку,
# ничего знать не надо, т.к. для этого юникод и изобретался - по юникоду
# символа сразу известно, что это за символ.
#
# Когда python читает код программы, он должен знать кодировку, в которой 
# этот код был сохранен. Вообще, поскольку во многих кодировках буквы 
# английского алфавита кодируются одинаково (так же, как в кодировке ascii),
# сам код python мог бы понять, просто используя таблицу ascii. При этом он,
# встречая произвольный текст в кавычках, даже может создавать из него
# обычные строки. Например, строка "текст" - это просто последовательность
# байт между кавычками, которую python поместит в объект типа str (в
# кодировке utf-8 это 10 байт). Но без реальной кодировки он не может
# правильно создавать юникод-строки. Встретив ту же строку, но с префиксом
# u"текст", он должен будет создать объект типа unicode. Для этого ему
# нужно узнать юникод каждого символа этой строки, т.е. нужно "понять"
# каждый символ, а этого не сделать без кодировки.
#
# Кодировку файла можно указать, разместив на первой или второй строке
# один из следующих комментариев: 
#     # -*- coding: кодировка -*-
#     # coding=кодировка
#
# Если кодировка не задана, python будет читать файл, используя какую-то
# кодировку по умолчанию. Интересно, что эта кодировка может отличаться от 
# той, которая используется в редакторе. Например, в редакторе Python
# IDLE может использоваться кодировка cp1251, а сам python по умолчанию
# может читать код, используя cp1252.
#
# При выводе строки через print она записывается в файл sys.stdout,
# кодировку которого можно узнать по атрибуту sys.stdout.encoding. Если
# выводится юникод-строка, ее символы будут кодироваться этой кодировкой.
# Если выводится обычная строка, она просто целиком скопируется в файл,
# без изменений (и далее отобразится в соответствии с sys.stdout.encoding).
# Поэтому в данных заметках текст с русскими символами записан в виде
# юникод-строк (u"...") - заметки сохранены в utf-8, и если
# sys.stdout.encoding отличается от utf-8, обычные строки при выводе
# через print отобразятся неверно.
#
# Конечно, удобно хранить строки в юникоде, а при отображении или записи
# куда-либо кодировать их нужной кодировкой. Это и сделано в python 3.x - 
# там все все строки хранят юникод, независимо от префикса "u".


s1 = "текст"    # Здесь python создаст обычную строку - объект типа str, содержащий
                # все байты между кавычками. В кодировке utf-8 слово "текст" - это
                # 10 байт: 209 130  208 181  208 186  209 129  209 130. Т.е. s1
                # будет содержать исходную строку в utf-8.

print len(s1)   # 10 (количество байт, а не реальных символов)
                
s2 = u"текст"   # Здесь python создаст юникод-строку - объект типа unicode, содержащий
                # юникоды символов, находящихся между кавычками. Поскольку python 
                # знает, что кодировка этого файла utf-8, по ней он поймет, что первые 
                # два байта (209 130) - это символ "т" с юникодом 1090, вторые два
                # байта - это символ "е" с юникодом 1077, и т.д.

print len(s2)   # 5
                
print s1    # Здесь байты из s1 будут скопированы в sys.stdout, т.е. в терминал,
            # и отображены в кодировке терминала. В данном случае, если эта кодировка
            # отличается от utf-8, строка будет отображена неверно. Например, если
            # кодировка терминала cp1251, то будет выведено С‚РµРєСЃС‚ - каждый
            # байт s1 будет интерпретирован по этой однобайтовой кодировке.
                
print s2    # Здесь юникоды из s2 будут сначала закодированы в соответствии с 
            # кодировкой sys.stdout, а потом записаны в терминал и отображены.
            # Поэтому, независимо от того, отличается ли кодировка терминала от 
            # utf-8, текст будет отображен верно (если только в s2 нет символов, 
            # для которых в кодировке терминала не предусмотрено кодов). Например,
            # если кодировка терминала cp1251, то в sys.stdout будет записана
            # последовательность из 5 байт: 242 229 234 241 242.

# У строк есть методы encode("кодировка") и decode("кодировка"). encode()
# кодирует строку в выбранной кодировке - т.е. можно юникод-строку
# представить в нужной кодировке. decode(), соответственно, декодирует 
# строку, используя заданную кодировку - т.е. из обычной строки можно 
# получить юникод.     

s3 = s1.decode("utf-8")  # Создаст юникод-строку из обычной, понимая байты по utf-8
s4 = s3.encode("utf-8")  # Создаст обычную строку из юникода, кодируя символы по utf-8

# Функция ord() принимает строку из одного символа и возвращает его значение:
# для обычной строки это значение байта, для юникод-строки это юникод. 
# chr() и unichr() принимают код/юникод и возвращают строку из одного символа
# (в документации написано, что chr() возвращает символ по кодировке ASCII).

print ord(s1[0]), ord(s2[0])  # 209 1090 (первый байт строки и юникод символа "т")
print chr(97), unichr(1090)   # a т

# Замечание: Если передать в print какой-то объект, отличный от строки,
# он сначала будет преобразован в строку (обычную, не юникод). Для
# некоторых объектов такое преобразование может привести к ошибке, если
# они содержат юникод-строки. Потому что в этом случае python может
# преобразовывать юникод-строки в обычные, используя, например, кодировку
# ASCII, а не кодировку терминала (sys.stdout.encoding). Например, для
# объекта Exception инструкция print Exception(u"Описание исключения")
# может привести к ошибке "UnicodeEncodeError: 'ascii' codec can't encode
# characters ...", если python попробует преобразовать u"Описание
# исключения" в обычную строку с помощью ASCII, в которой нет нужных
# символов. Поэтому использование юникод-строк не гарантирует, что все
# будет отображаться без проблем - важно, чтобы при отображении этих
# строк использовалась подходящая кодировка.
